1. 延时
```c fold
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

vTaskDelay(pdMS_TO_TICKS(1000));
```
1. 任务相关
```c fold
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

xTaskCreate(task_A, "task A", 2048, NULL, 5, NULL);
```
2. 队列
```c fold
#include <stdio.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"
#include "esp_log.h"
#include "malloc.h"
#include <string.h>

QueueHandle_t quue_handle = NULL;

typedef struct{
    int value;
}queue_data_t;

// 发送数据
void task_A(void* param){
    queue_data_t data;
    memset(&data, 0, sizeof(data));
    while(1) {
        if (xQueueSend(quue_handle, &data, 100)) {
            ESP_LOGI("task A", "send data: %d", data.value);
        } else {
            ESP_LOGI("task A", "send data timeout");
        }
        vTaskDelay(pdMS_TO_TICKS(1000));
        data.value++;
    }
}

// 接受数据
void task_B(void* param){
    while(1) {
        queue_data_t data;
        if (pdTRUE == xQueueReceive(quue_handle, &data, 100)) {
            ESP_LOGI("task B", "receive data: %d", data.value);
        } else {
            ESP_LOGI("task B", "receive data timeout");
        }    
    }
}

void app_main(void)
{
    quue_handle = xQueueCreate(10, sizeof(queue_data_t));
    if (quue_handle == NULL) {
        ESP_LOGE("main", "create queue failed");
        return;
    }

    xTaskCreate(task_A, "task A", 2048, NULL, 5, NULL);
    xTaskCreate(task_B, "task B", 2048, NULL, 5, NULL);
    return;
```
3. 信号量
	1. xSemaphoreCreateBinary与xSemaphoreCreateMutex区别
		1. 创建时的初始状态不同，xSemaphoreCreateBinary创建后信号量为空，可以Give，也可以被Take（会被阻塞）。xSemaphoreCreateMutex创建成功后，表示锁可用，必须要先Take。
		2. 优先级继承，只有xSemaphoreCreateMutex支持
		3. 持有与释放
			1. xSemaphoreCreateBinary无持有者概念，谁都可以持有或者释放
			2. xSemaphoreCreateMutex必须是谁持有、谁释放。
```c fold
#include <stdio.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/semphr.h"
#include "esp_log.h"

SemaphoreHandle_t xSemaphore = NULL;

// 获取信号量
void taskA(void* param) {
    while(1) {
        if(xSemaphoreTake(xSemaphore, portMAX_DELAY) == pdTRUE) {
            ESP_LOGI("Task A", "Accessing shared resource");
        }
    }
}

// 释放信号量
void taskB(void* param) {
    while(1) {
        xSemaphoreGive(xSemaphore);
        vTaskDelay(pdMS_TO_TICKS(100)); // Wait before trying again
    }
}

void app_main(void)
{
    return;
}
```
4. 事件组
```c fold
#include <stdio.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/event_groups.h"
#include "esp_log.h"

static EventGroupHandle_t event_group = NULL;


// 设置事件组
void taskA(void *pvParameters) {
    while (1)
    {
        xEventGroupSetBits(event_group, BIT0);
        vTaskDelay(pdMS_TO_TICKS(1000));
        xEventGroupSetBits(event_group, BIT1);
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}

// 等待事件组
void taskB(void *para) {
    EventBits_t bits;
    while (1)
    {
        bits = xEventGroupWaitBits(event_group, BIT0 | BIT1, pdTRUE, pdFALSE, portMAX_DELAY);
        if (bits & BIT0) {
            ESP_LOGI("taskB", "BIT0 is set\n");
        }
        if (bits & BIT1) {
            ESP_LOGI("taskB", "BIT1 is set\n");
        }
    }
}



void app_main(void)
{
    TaskHandle_t taskA_handle = NULL;
    TaskHandle_t taskB_handle = NULL;
    event_group = xEventGroupCreate();
    xTaskCreate(taskA, "taskA", 2048, NULL, 5, &taskA_handle);
    xTaskCreate(taskB, "taskB", 2048, NULL, 5, &taskB_handle);
    return;
}

```
5. 事件通知
```c fold
#include <stdio.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_log.h"

static TaskHandle_t taskA_handle = NULL;
static TaskHandle_t taskB_handle = NULL;

// 事件通知
void taskA(void *arg) {
    int i = 0;
    while (1) {
        // 发送事件通知给任务B
        if (taskB_handle != NULL) {
            xTaskNotify(taskB_handle, i++, eSetValueWithOverwrite);
            ESP_LOGI("TaskA", "Notified TaskB");
            vTaskDelay(pdMS_TO_TICKS(10));
        }
    }
}

// 事件接受
void taskB(void* arg) {
    int notifiedValue;
    while (1) {
        // 等待任务A的通知
        if (xTaskNotifyWait(0, 0, &notifiedValue, portMAX_DELAY) == pdTRUE) {
            ESP_LOGI("TaskB", "Received notification with value: %d", notifiedValue);
        }
    }
}

void app_main(void)
{
    xTaskCreate(taskB, "TaskB", 2048, NULL, 5, &taskB_handle);
    xTaskCreate(taskA, "TaskA", 2048, NULL, 5, &taskA_handle);
    
}
```
6. IO控制
```c fold
#include <stdio.h>
#include "driver/gpio.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_log.h"

#define LED_GPIO GPIO_NUM_2

void taskA(void *pvParameters)
{
    gpio_config_t led_gpio_config = {
        .pin_bit_mask = 1 << GPIO_NUM_2,
        .mode = GPIO_MODE_OUTPUT,
        .pull_up_en = GPIO_PULLUP_DISABLE,
        .pull_down_en = GPIO_PULLDOWN_DISABLE,
        .intr_type = GPIO_INTR_DISABLE
    };
    gpio_config(&led_gpio_config);
    UBaseType_t highWaterMark;
    while (1)
    {
        gpio_set_level(LED_GPIO, 1);
        vTaskDelay(pdMS_TO_TICKS(500));
        gpio_set_level(LED_GPIO, 0);
        vTaskDelay(pdMS_TO_TICKS(500));
        // 检查堆栈高水位标记
        highWaterMark = uxTaskGetStackHighWaterMark(NULL);
        ESP_LOGI("STACK", "剩余堆栈: %d 字节", highWaterMark * sizeof(StackType_t));
    }
}


void app_main(void)
{
    xTaskCreatePinnedToCore(taskA, "TaskA", 4096, NULL, 5, NULL, 1);
}

```